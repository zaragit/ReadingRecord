# Chapter02. 테스트

## 단위 테스트(Unit Test)

"테스트는 가능하면 작은 단위로 쪼개서 집중해서 할 수 있어야 한다."  
여러가지 대상을 한번에 테스트하게 된다면 과정이 복잡해지고, 발생한 문제에 대해 정확한 오류를 파악하는데 오랜 시간이 걸릴 수 있다. 때문에 관심사 별로 가능한 작은 단위의 테스트 코드를 작성하는 것이 좋다.

## 테스트코드의 장점

**1. 언제든지 실행이 가능하다**  
　웹을 통해서 테스트를 한다면 애플리케이션의 기본적인 기능이 개발되고 서버로 배치되어야 테스트를 할 수 있지만 테스트 코드는 언제든지 실행이 가능하다.  
**2. 자동수행이 가능하다**  
　테스트 코드는 자동으로 수행되며 빠르고 정확하게 언제든지 실행 할 수 있다.  
　코드로 되어 있기 때문에 사람이 직접 테스트 했을 때 생길 수 있는 휴먼 에러가 없다.  
**3. 변화에 대응하기 편하다**   
　수정한 코드에 대해서 빠르게 검증할 수 있다.  
　기능이 추가 됨에 따라 테스트 코드도 함께 수정하는 식으로 점진적인 개발이 가능하다.

## TDD

테스트 코드를 먼저 만들고, 만든 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법이다.  
실패한 테스트를 성공시키기 위한 목적의 코드가 아니면 작성하지 않아야 하며, 매번 테스트가 성공하는 것을 보면서 작성하기 때문에 작성한 코드에 대한 확신을 가질 수 있다.  
먼저 테스트 코드를 작성하기 때문에 애플리케이션의 모든 코드가 테스트 코드로 검증이 된 것이라고 볼 수 있다.

## JUnit

자바의 테스팅 프레임워트

#### JUnit 어노테이션

- **@Test**  
  JUnit은 public void에 @Test어노테이션이 붙은 메소드를 테스트 메소드로 허용한다.   
  expected 엘리먼트로 테스트 메소드 실행 중에 발생할 예외를 지정할 수 있다.  
  (JUnit5에서는 Assertions.assertThrows 와 같은 메소드를 사용해야 한다.)

- **@Before**  
  테스트 클래스에 @Test 메소드 실행 **전**에 실행된다.
- **@After**  
  테스트 클래스에 @Test 메소드 실행 **후**에 실행된다.

- **@BeforeClass**  
  @Before와 다르게 딱 한번만 실행된다.
- **@AfterClass**  
  @After와 다르게 딱 한번만 실행된다.

  ![Screen Shot 2021-03-17 at 21 20 29 PM](https://user-images.githubusercontent.com/74804564/111466936-3bd30b00-8767-11eb-87db-f3c5495ee185.png)

- **@RunWith**  
  JUnit 프레임워크의 테스트 실행 방법을 확장할 때 사용하고, 확장 클래스를 지정해 줘야 한다.   
  SpringJUnit4ClassRunner 확장 클래스의 경우 테스트가 사용할 애플리케이션 컨텍스트를 만들고 관리해 준다.

- **@ContextConfiguration**  
  자동으로 만들어 줄 애플리케이션 컨텍스트의 파일 경로나 설정 클래스 파일을 지정한다.  
  locations - 경로  
  classes - 클래스

- **@DirtiesContext**  
  클래스나 메소드에서 애플리케이션 컨텍스트를 변경한다는 것을 테스트 프레임워크에게 알려준다.  
  이후 진행될 테스트에 영향을 주지 않도록 테스트 종료 후 애플리케이션 컨텍스트를 새로 만든다.

## Hamcrest

JUnit와 같이 사용되는 Matcher 라이브러리
테스트 코드를 작성할 때 좀 더 자연스럽고 직관적으로 코딩할 수 있도록 도와준다.  
주로 assertThat 메소드와 Matcher를 혼합하여 사용한다.  
첫 번째 파라미터의 값과 뒤에 매처(Matcher)라고 불리는 조건으로 비교해서 일치하면 다음으로 넘어간다.

#### Hamcrest Matcher

- **is**  
  equal()의 동작을 하지만 주로 다른 Matcher와 같이 사용해서 코드를 좀 더 직관적으로 작성할 수 있게 하는 용도로 사용  
  ex)
  - is(not(sameInstance(instance)))
  - is(nullValue())
- **not**  
  뒤에 나오는 결과를 부정
- **sameInstance**  
  같은 인스턴스인지 비교
- **hasItem**  
  컬렉션의 원소인지 검사
- **either&or**  
  either().or() 형태로 사용하며 두 결과를 or 조건으로 비교
- **nullValue**  
  값이 null인지 확인

## 학습 테스트

자신이 만들지 않고 다른사람이 만든 라이브러리나 프레임워크 등에 대해서 작성하는 테스트  
기능에 대한 검증을 목적으로 하기보단 기능의 동작과 사용방법을 얼마나 제대로 이해하고 있는지 검증

#### 학습 테스트의 장점

- 코드로 작성되기 때문에 다양한 조건에 따라 기능이 어떻게 동작하는지 빠르게 확인 가능하다.
- 테스트 중 좀 더 나은 사용 방법을 발견하면 수정해서 다른 개발자와 공유할 수 있다.
- 새로운 버전을 적용하기 전에 학습 테스트를 통해서 미리 번경된 점과 버그를 확인할 수 있다.
- 테스트 코드를 작성하는 연습이 될 수 있다.

## 버그 테스트

버그가 발생하면 바로 기능을 수정하지 않고, 버그가 발생하는 테스트 코드를 먼저 작성한 다음 테스트가 통과 될 수 있도록 기능을 수정한다.

#### 버그 테스트의 장점

- 부족했던 테스트의 완성도를 높여준다.
- 버그에 대해서 좀 더 명확하게 분석하고 고민해 볼 수 있는 기회가 된다.
